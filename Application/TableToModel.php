<?php

/**
 * Used to make database tables into phpdoc'ed model files
 *
 * It can be used to create the class skeleton or to update the properties section
 * It keeps the description and access and outputs the code for you to copy
 *
 * @todo get to work with oracle, mssql
 *
 * @author paul.visco@roswellpark.org
 */
class sb_Application_TableToModel {
	/**
	 * A PDO connection to use for reading from the db
	 * @var PDO
	 */
	protected $db;

	/**
	 * Class skeleton
	 * @var string
	 */
	public $class_doc = <<<'DOC'
/**
* Class CLASS
* autogenerated by sb_Application_TableToModel
*
* @author EMAIL
* @version 1.0
*/

class CLASS{
DOC;

	/**
	 * Convertt a database table to a model
	 *
	 * <code>
	 * $setup = new sb_Setup_TableToModel();
	 * </code>
	 *
	 */
	public function __construct(PDO $db) {
		$this->db = $db;
	}

	/**
	 * Creates a model
	 *
	 * <code>
	 * $setup->to_model('group');
	 * </code>
	 *
	 * @return string The PHP for the class
	 */
	public function to_model($table, $model_name='') {
		$model_name = !empty($model_name) ? $model_name : $table;
		$model_name = ucwords($model_name);
		$php = $this->class_doc;
		$php = str_replace("CLASS", $model_name, $php);
		$fields = $this->get_columns($table);
		foreach($fields as $field) {
			$php .= $this->field_to_doc_block($field);
		}

		$php .= "\n}\n";

		return $php;
	}

	/**
	 * Loads the updates info from the database and mixes it with the current description
	 *
	 * <code>
	 * $setup->update_properties('Group', 'group');
	 * </code>
	 *
	 * @param string $model_name The name of the model to use as a basis
	 * @return string The PHP for the class properties
	 */
	public function update_properties($table, $model_name) {

		$php = '';

		$fields = $this->get_columns($table);

		$class = new ReflectionClass($model_name);
		
		$model_properties = $class->getProperties();
		$model_properties_by_name = Array();

		foreach($model_properties as $property){
			$model_properties_by_name[$property->getName()] = $property;
		}

		unset($model_properties);

		$property_names = array_keys($model_properties_by_name);
		foreach($fields as $field){
			if(in_array($field->Field, $property_names)){

				$property = $model_properties_by_name[$field->Field];

				//check to see if the data is the same
				$old_doc_block = $property->getDocComment();

				preg_match("~(.*)\* @var.*~s", $old_doc_block, $matches);

				if(isset($matches[1])){
					$property->description = rtrim($matches[1]);
					$new_doc_block = $this->field_to_doc_block($field, $property);
				}

				$php .= $new_doc_block;
			} else {
				$php .= $this->field_to_doc_block($field);
			}
		}
		
		return $php."\n";
	}
	
	/**
	 * Loads the columns from mysql
	 * @return Array of rows
	 */
	protected function get_columns($table) {
		$sql = "DESCRIBE ".$table;
		$stmt = $this->db->prepare($sql);

		$result = $stmt->execute();
		if($result){
			$stmt->setFetchMode(PDO::FETCH_OBJ);
			return $stmt->fetchAll();
		} else {
			return Array();
		}
	}

	/**
	 * Converts a mysql field to php docs, if property already exists, it just
	 * updates keeping old description and access
	 *
	 * @param Object $field  The mysql rows from DESCRIBE
	 * @param ReflectionProperty $property The property from the prefined class
	 * @return string The PHP for the property
	 */
	protected function field_to_doc_block($field, $property=null) {
		$doc = "\n\n\t";
		if(is_null($property)){
			$doc .= "/**\n\t * ";
			$doc .= "DESCRIPTION\n\t *";
		} else {
			$doc .= $property->description;
		}

		$doc .= "\n\t * @var ";
		$doc .= $field->Type;
		$props = Array();
		if($field->Key) {
			$props[] = ' KEY='.$field->Key;
		}

		if($field->Default) {
			$props[] = ' DEFAULT='.$field->Default;
		}

		$doc .= implode(", ", $props);
		$doc .= "\n\t */\n\t";
		if(!is_null($property)){
			$doc .= $property->isPublic() ? 'public' : '';
			$doc .= $property->isPrivate() ? 'private' : '';
			$doc .= $property->isProtected() ? 'protected' : '';
		} else {
			$doc .= "public";
		}
		$doc .= " \$".$field->Field.';';


		return $doc;
	}

}

?>